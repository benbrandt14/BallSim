var documenterSearchIndex = {"docs":
[{"location":"#BallSim.jl","page":"Home","title":"BallSim.jl","text":"A high-performance, multi-threaded 2D and 3D physics engine written in Julia. Designed for massive particle simulations (N  10^6) with a decoupled rendering pipeline capable of 8K visualizations.\n\nInspired by the work of Alexander Gustafsson","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Performance: Structure-of-Arrays (SoA) data layout with multi-threaded physics kernels.\nModular Architecture: Physics, Geometry, and Rendering are strictly decoupled.\nDeclarative Configuration: Full simulation control via YAML files (solvers, fields, boundaries).\n\"Darkroom\" Rendering: Headless HDF5 export pipeline with a separate high-res rendering tool (supports Logarithmic Tone Mapping).\nExtensible: Easy interfaces for defining new Shapes, Force Fields, and Scenarios.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"git clone https://github.com/benbrandt14/BallSim.jl\ncd BallSim.jl\n# Option 1: Quick Start (Installs Julia if needed, instantiates, and tests)\n./setup.sh\n\n# Option 2: Manual Setup\njulia --project=. -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"#Analytics-and-Verification","page":"Home","title":"Analytics & Verification","text":"We use agent-based workflows to verify physics correctness directly in the documentation.","category":"section"},{"location":"#1.-Physics-Verification-(Trajectory-Analysis)","page":"Home","title":"1. Physics Verification (Trajectory Analysis)","text":"We simulate a single particle under gravity to verify the parabolic trajectory.\n\nusing BallSim\nusing CairoMakie\nusing StaticArrays\nusing LaTeXStrings\n\n# Configure a minimal simulation\n# We use a custom script approach since the high-level API writes to disk.\n# Here we manually step the physics to capture data in memory.\n\n# 1. Setup System\nconst T = Float32\nconst D = 2\nN = 1\nsys = BallSim.Common.BallSystem(N, D, T)\nsys.data.pos[1] = SVector{D, T}(0.0, 10.0)\nsys.data.vel[1] = SVector{D, T}(5.0, 0.0) # Horizontal launch\nsys.data.mass[1] = 1.0\n\n# 2. Setup Solver & Field\nsolver = BallSim.Physics.CCDSolver(T(0.01), T(0.8), 1) # dt=0.01, res=0.8\n# Standard Gravity downwards\ngravity = BallSim.Fields.UniformField(SVector{D, T}(0.0, -9.81))\n# Simple box boundary\nboundary = BallSim.Shapes.Box(T(20.0), T(20.0))\n\n# 3. Run Simulation\nsteps = 100\ntrajectory_x = Float64[]\ntrajectory_y = Float64[]\n\nfor i in 1:steps\n    push!(trajectory_x, sys.data.pos[1][1])\n    push!(trajectory_y, sys.data.pos[1][2])\n    BallSim.Physics.step!(sys, solver, boundary, gravity)\nend\n\n# 4. Plot Results\nfig = Figure()\nax = Axis(fig[1, 1], title = L\"Trajectory under $g=9.81$\", xlabel = \"x (m)\", ylabel = \"y (m)\")\nlines!(ax, trajectory_x, trajectory_y, color = :blue, label = \"Particle Path\")\n\n# Add ground line\nhlines!(ax, [-10.0], color = :red, linestyle = :dash, label = \"Ground\")\n\naxislegend(ax)\nsave(\"simulation_analytics.svg\", fig) # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#2.-Force-Diagram-(Free-Body-Diagram)","page":"Home","title":"2. Force Diagram (Free Body Diagram)","text":"A declarative vector diagram representing the forces on a ball.\n\nusing TikzPictures\nusing LaTeXStrings\n\n# Create a TikZ diagram\ntp = TikzPicture(L\"\"\"\n    \\draw[fill=gray!20] (0,0) circle (1cm);\n    \\draw[->, thick, red] (0,0) -- (0,-2) node[right] {$F_g = mg$};\n    \\draw[->, thick, blue] (0,0) -- (2,0) node[above] {$v$};\n    \\node at (0,0) {m};\n\"\"\", options=\"scale=1.5\")\n\nTikzPictures.save(SVG(\"fbd\"), tp) # hide\nnothing # hide\n\n(Image: )","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#1.-Command-Line","page":"Home","title":"1. Command Line","text":"Run the simulation using the default config.yaml:\n\njulia --project=. sim.jl\n\nOr specify a custom configuration file:\n\njulia --project=. sim.jl my_config.yaml\n\nConfiguration Structure (config.yaml):\n\nsimulation:\n  type: Spiral\n  params:\n    N: 50000\n  duration: 10.0\n  dimensions: 3\nphysics:\n  dt: 0.002\n  solver: CCD\n  solver_params:\n    restitution: 0.5\n    substeps: 8\n  gravity:\n    type: Central\n    params:\n      strength: 20.0\n      mode: attractor\n      center: [0.0, 0.0, 0.0]\n  boundary:\n    type: Circle\n    params:\n      radius: 1.0\n\n# Example 3D Box (Requires dimensions: 3)\n# boundary:\n#   type: Box\n#   params:\n#     width: 10.0\n#     height: 10.0\n#     depth: 10.0\n\noutput:\n  mode: render\n  res: 800\n  fps: 60\n  filename: sandbox/simulation\n  projection: xy","category":"section"},{"location":"#2.-The-Darkroom-(High-Res-Visualization)","page":"Home","title":"2. The Darkroom (High-Res Visualization)","text":"Turn raw HDF5 data into art using the standalone renderer tool.\n\n# Usage: julia tools/render_frame.jl <h5_file> <frame_index>\njulia --project=. tools/render_frame.jl sandbox/data_123456.h5 10\n\n\nOutput: A 4K (3840x2160) PNG with logarithmic tone mapping.\nPerformance: Multi-threaded accumulation buffer; renders 1M particles in milliseconds.","category":"section"},{"location":"#3.-ParaView-Export-(VTK)","page":"Home","title":"3. ParaView Export (VTK)","text":"Export simulations directly to .vtu (Unstructured Grid) or .vtp (PolyData) formats for analysis in ParaView.\n\nConfiguration: Set mode to \"export\" and use a filename with .vtu or .vtp extension.\n\noutput:\n  mode: export\n  filename: sandbox/simulation.vtu\n  fps: 60\n\nFeatures:\n\nData Fields: Exports Position, Velocity, Mass, Active status, and Collision counts.\nTime Series: Generates a sequence of files (e.g., simulation_00001.vtu) automatically recognized by ParaView as a time series.","category":"section"},{"location":"#Extension-Guide","page":"Home","title":"Extension Guide","text":"BallSim is built on a \"Plugin\" architecture. You can extend it without modifying the core loop.","category":"section"},{"location":"#1.-Adding-a-New-Scenario","page":"Home","title":"1. Adding a New Scenario","text":"Create a struct that subtypes Common.AbstractScenario{D}.\n\n# src/Scenarios.jl\n\nstruct GalaxyScenario <: Common.AbstractScenario{2}\n    N::Int\nend\n\n# A. Define Initial Conditions\nfunction Scenarios.initialize!(sys::Common.BallSystem{2, T, S}, scen::GalaxyScenario) where {T, S}\n    # Initialize sys.data.pos and sys.data.vel here...\nend\n\n# B. Define Physics Rules (Solver Config)\nfunction Common.get_default_solver(scen::GalaxyScenario)\n    return Physics.CCDSolver(0.001f0, 1.0f0, 8)\nend\n\n# C. Define Forces\nfunction Common.get_force_field(scen::GalaxyScenario)\n    # Combine Gravity and Drag\n    g = Fields.CentralField(SVector(0f0, 0f0), 100.0f0)\n    d = Fields.ViscousDrag(0.1f0)\n    return Fields.CombinedField((g, d))\nend\n","category":"section"},{"location":"#2.-Adding-a-New-Shape","page":"Home","title":"2. Adding a New Shape","text":"Create a struct that subtypes Common.AbstractBoundary{D}.\n\n# src/Shapes.jl\n\nstruct Triangle <: Common.AbstractBoundary{2}\n    p1::SVector{2, Float32}\n    p2::SVector{2, Float32}\n    p3::SVector{2, Float32}\nend\n\n# A. Signed Distance Function\nfunction Common.sdf(b::Triangle, p::SVector{2}, t)\n    # Return distance (Negative = Inside, Positive = Outside)\nend\n\n# B. Normal Vector\nfunction Common.normal(b::Triangle, p::SVector{2}, t)\n    # Return normalized vector pointing OUT of the shape\nend\n","category":"section"},{"location":"#3.-Adding-a-New-Force-Field","page":"Home","title":"3. Adding a New Force Field","text":"Create a struct that subtypes Fields.AbstractField.\n\n# src/Fields.jl\n\nstruct MagneticField <: Fields.AbstractField\n    strength::Float32\nend\n\n# Implement the Functor\nfunction (f::MagneticField)(p, v, t)\n    # Return Force Vector F = q(v x B) ...\n    return SVector(...)\nend\n","category":"section"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#BallSim.Common.BallSystem","page":"Home","title":"BallSim.Common.BallSystem","text":"BallSystem{D, T, S}\n\nPhysical state.\n\nD: Dimensions (2, 3)\nT: Precision (Float32, Float64)\nS: Storage Type (StructArray{...})\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Common.detect_collision-Union{Tuple{D}, Tuple{BallSim.Common.AbstractBoundary{D}, StaticArraysCore.SVector{D}, Any}} where D","page":"Home","title":"BallSim.Common.detect_collision","text":"detect_collision(boundary, p, t)\n\nChecks for collision and returns (collided, dist, normal).\n\ncollided: Bool, true if penetration depth > 0\ndist: Float32, penetration depth (positive means collision)\nnormal: SVector, direction to resolve collision (points into the obstacle / forbidden region)\n\nDefault implementation calls sdf and normal.\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Shapes.Inverted","page":"Home","title":"BallSim.Shapes.Inverted","text":"Inverted{D, B}\n\nWraps another boundary B and inverts its logic. Used to trap particles INSIDE a shape (e.g., inside a Circle).\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Common.sdf-Tuple{BallSim.Shapes.Box3D, StaticArraysCore.SVector{3}, Any}","page":"Home","title":"BallSim.Common.sdf","text":"sdf(b::Box3D, p::SVector{3}, t)\n\nSigned Distance Function for a 3D Box.\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> b = Shapes.Box3D(2.0f0, 2.0f0, 2.0f0);\n\njulia> Common.sdf(b, SVector(0.0f0, 0.0f0, 0.0f0), 0.0f0)\n-1.0f0\n\njulia> Common.sdf(b, SVector(2.0f0, 0.0f0, 0.0f0), 0.0f0)\n1.0f0\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Common.sdf-Tuple{BallSim.Shapes.Circle, StaticArraysCore.SVector{2}, Any}","page":"Home","title":"BallSim.Common.sdf","text":"sdf(b::Circle, p::SVector{2}, t)\n\nSigned Distance Function for a 2D Circle. Returns negative if inside, positive if outside.\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> c = Shapes.Circle(1.0f0);\n\njulia> Common.sdf(c, SVector(0.0f0, 0.0f0), 0.0f0)\n-1.0f0\n\njulia> Common.sdf(c, SVector(2.0f0, 0.0f0), 0.0f0)\n1.0f0\n\njulia> Common.sdf(c, SVector(1.0f0, 0.0f0), 0.0f0)\n0.0f0\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Physics.step!-Union{Tuple{G}, Tuple{S}, Tuple{T}, Tuple{D}, Tuple{BallSim.Common.BallSystem{D, T, S}, BallSim.Physics.CCDSolver, BallSim.Common.AbstractBoundary{D}, G}} where {D, T, S, G}","page":"Home","title":"BallSim.Physics.step!","text":"step!(sys, solver, boundary, gravity_func)\n\nThe main physics loop. Updates particle positions and velocities based on:\n\nGravity / Force Fields\nExplicit Euler Integration\nContinuous Collision Detection (approximate via substeps) with the Boundary.\n\nArguments\n\nsys: The BallSystem containing particle data.\nsolver: The CCDSolver configuration (dt, restitution, substeps).\nboundary: The geometric boundary (e.g., Circle, Box).\ngravity_func: A callable f(p, v, m, t) returning force vector.\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> sys = Common.BallSystem(1, 2); # 1 particle, 2D\n\njulia> sys.data.pos[1] = SVector(0.0f0, 0.0f0);\n\njulia> sys.data.vel[1] = SVector(1.0f0, 0.0f0);\n\njulia> sys.data.active[1] = true;\n\njulia> solver = Physics.CCDSolver(0.1f0, 1.0f0, 1);\n\njulia> boundary = Shapes.Circle(10.0f0);\n\njulia> gravity = (p, v, m, t) -> SVector(0.0f0, -9.8f0); # Simple gravity\n\njulia> Physics.step!(sys, solver, boundary, gravity);\n\njulia> sys.t â‰ˆ 0.1f0\ntrue\n\njulia> sys.data.pos[1][2] < 0.0f0 # Moved down due to gravity\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.load_frame!-Union{Tuple{T}, Tuple{D}, Tuple{BallSim.Common.BallSystem{D, T}, HDF5.File, Int64}} where {D, T}","page":"Home","title":"BallSim.SimIO.load_frame!","text":"load_frame!(sys::BallSystem, file::HDF5.File, index::Int)\n\nOverwrites sys with data from the file.\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.save_frame-Union{Tuple{T}, Tuple{D}, Tuple{HDF5.File, Int64, BallSim.Common.BallSystem{D, T}}} where {D, T}","page":"Home","title":"BallSim.SimIO.save_frame","text":"save_frame(file::HDF5.File, index::Int, sys::BallSystem)\n\nSaves the current state to the HDF5 group /frame_{index}. Saves generic SVector components (x, y...) as separate arrays.\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.save_vtk-Union{Tuple{T}, Tuple{D}, Tuple{String, Int64, BallSim.Common.BallSystem{D, T}}} where {D, T}","page":"Home","title":"BallSim.SimIO.save_vtk","text":"save_vtk(prefix::String, index::Int, sys::BallSystem)\n\nSaves the current state to a VTK file (UnstructuredGrid .vtu by default).\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Fields.UniformField","page":"Home","title":"BallSim.Fields.UniformField","text":"UniformField{D, T}\n\nA constant force field (e.g., gravity) applied uniformly to all particles. F = m * vector\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> g = Fields.UniformField(SVector(0.0f0, -9.8f0));\n\njulia> g(SVector(0f0,0f0), SVector(0f0,0f0), 1.0f0, 0.0f0) == SVector(0.0f0, -9.8f0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Fields.VortexField","page":"Home","title":"BallSim.Fields.VortexField","text":"VortexField{D, T}\n\nA force field that applies a tangential force around a center. F = (strength / r^2) * tangent_vector\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> v = Fields.VortexField(SVector(0.0f0, 0.0f0), 1.0f0);\n\njulia> v(SVector(1.0f0, 0.0f0), SVector(0f0,0f0), 1.0f0, 0.0f0)\n2-element SVector{2, Float32} with indices SOneTo(2):\n -0.0\n  1.0\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Vis.compute_frame!-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Matrix{Float32}, BallSim.Common.BallSystem{D, T, S}, Float64, Any, Any, BallSim.Common.VisualizationConfig}} where {D, T, S}","page":"Home","title":"BallSim.Vis.compute_frame!","text":"compute_frame!(grid, sys, limit, u, v, cfg)\n\nComputes the visualization frame based on config. Projects 3D particles if necessary.\n\n\n\n\n\n","category":"method"}]
}
