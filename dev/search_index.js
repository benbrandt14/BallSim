var documenterSearchIndex = {"docs":
[{"location":"#BallSim","page":"Home","title":"BallSim","text":"Documentation for BallSim.","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"julia> using BallSim","category":"section"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"#BallSim.Common.BallSystem","page":"Home","title":"BallSim.Common.BallSystem","text":"BallSystem{D, T, S}\n\nPhysical state.\n\nD: Dimensions (2, 3)\nT: Precision (Float32, Float64)\nS: Storage Type (StructArray{...})\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Shapes.Inverted","page":"Home","title":"BallSim.Shapes.Inverted","text":"Inverted{D, B}\n\nWraps another boundary B and inverts its logic. Used to trap particles INSIDE a shape (e.g., inside a Circle).\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Common.sdf-Tuple{BallSim.Shapes.Circle, StaticArraysCore.SVector{2}, Any}","page":"Home","title":"BallSim.Common.sdf","text":"sdf(b::Circle, p::SVector{2}, t)\n\nSigned Distance Function for a 2D Circle. Returns negative if inside, positive if outside.\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> c = Shapes.Circle(1.0f0);\n\njulia> Common.sdf(c, SVector(0.0f0, 0.0f0), 0.0f0)\n-1.0f0\n\njulia> Common.sdf(c, SVector(2.0f0, 0.0f0), 0.0f0)\n1.0f0\n\njulia> Common.sdf(c, SVector(1.0f0, 0.0f0), 0.0f0)\n0.0f0\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Physics.step!-Union{Tuple{G}, Tuple{S}, Tuple{T}, Tuple{D}, Tuple{BallSim.Common.BallSystem{D, T, S}, BallSim.Physics.CCDSolver, BallSim.Common.AbstractBoundary{D}, G}} where {D, T, S, G}","page":"Home","title":"BallSim.Physics.step!","text":"step!(sys, solver, boundary, gravity_func)\n\nThe main physics loop. Updates particle positions and velocities based on:\n\nGravity / Force Fields\nExplicit Euler Integration\nContinuous Collision Detection (approximate via substeps) with the Boundary.\n\nArguments\n\nsys: The BallSystem containing particle data.\nsolver: The CCDSolver configuration (dt, restitution, substeps).\nboundary: The geometric boundary (e.g., Circle, Box).\ngravity_func: A callable f(p, v, m, t) returning force vector.\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> sys = Common.BallSystem(1, 2); # 1 particle, 2D\n\njulia> sys.data.pos[1] = SVector(0.0f0, 0.0f0);\n\njulia> sys.data.vel[1] = SVector(1.0f0, 0.0f0);\n\njulia> sys.data.active[1] = true;\n\njulia> solver = Physics.CCDSolver(0.1f0, 1.0f0, 1);\n\njulia> boundary = Shapes.Circle(10.0f0);\n\njulia> gravity = (p, v, m, t) -> SVector(0.0f0, -9.8f0); # Simple gravity\n\njulia> Physics.step!(sys, solver, boundary, gravity);\n\njulia> sys.t â‰ˆ 0.1f0\ntrue\n\njulia> sys.data.pos[1][2] < 0.0f0 # Moved down due to gravity\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.load_frame!-Union{Tuple{T}, Tuple{D}, Tuple{BallSim.Common.BallSystem{D, T}, HDF5.File, Int64}} where {D, T}","page":"Home","title":"BallSim.SimIO.load_frame!","text":"load_frame!(sys::BallSystem, file::HDF5.File, index::Int)\n\nOverwrites sys with data from the file.\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.save_frame-Union{Tuple{T}, Tuple{D}, Tuple{HDF5.File, Int64, BallSim.Common.BallSystem{D, T}}} where {D, T}","page":"Home","title":"BallSim.SimIO.save_frame","text":"save_frame(file::HDF5.File, index::Int, sys::BallSystem)\n\nSaves the current state to the HDF5 group /frame_{index}. Saves generic SVector components (x, y...) as separate arrays.\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.SimIO.save_vtk-Union{Tuple{T}, Tuple{D}, Tuple{String, Int64, BallSim.Common.BallSystem{D, T}}} where {D, T}","page":"Home","title":"BallSim.SimIO.save_vtk","text":"save_vtk(prefix::String, index::Int, sys::BallSystem)\n\nSaves the current state to a VTK file (UnstructuredGrid .vtu by default).\n\n\n\n\n\n","category":"method"},{"location":"#BallSim.Fields.UniformField","page":"Home","title":"BallSim.Fields.UniformField","text":"UniformField{D, T}\n\nA constant force field (e.g., gravity) applied uniformly to all particles. F = m * vector\n\nExample\n\njulia> using BallSim, StaticArrays\n\njulia> g = Fields.UniformField(SVector(0.0f0, -9.8f0));\n\njulia> g(SVector(0f0,0f0), SVector(0f0,0f0), 1.0f0, 0.0f0) == SVector(0.0f0, -9.8f0)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#BallSim.Vis.compute_frame!-Union{Tuple{S}, Tuple{T}, Tuple{D}, Tuple{Matrix{Float32}, BallSim.Common.BallSystem{D, T, S}, Float64, Any, Any, BallSim.Common.VisualizationConfig}} where {D, T, S}","page":"Home","title":"BallSim.Vis.compute_frame!","text":"compute_frame!(grid, sys, limit, u, v, cfg)\n\nComputes the visualization frame based on config. Projects 3D particles if necessary.\n\n\n\n\n\n","category":"method"}]
}
